/*
  ESP32 - MPU-6050 & MS5611 Controlled 3-DOF Stewart Platform
  with DYNAMIC HEAVE (HEIGHT) CONTROL via BAROMETER
  
  This code uses an MPU-6050 for Roll/Pitch and an
  MS5611 Barometer/Altimeter for Heave (Raise/Lower).
  
  THIS VERSION USES THE "MS5611 by Rob Tillaart" LIBRARY.

  WARNING: This method is EXPERIMENTAL. It will be "jittery"
  as the sensor reacts to all air pressure changes. The
  filter in the code helps smooth this.

  ESP32 PINOUT:
  - Servo 1: Pin GPIO 13
  - Servo 2: Pin GPIO 12
  - Servo 3: Pin GPIO 14
  - MPU SCL: Pin GPIO 22
  - MPU SDA: Pin GPIO 21
  - MS5611 SCL: Pin GPIO 22 (Shared)
  - MS5611 SDA: Pin GPIO 21 (Shared)
*/

// --- Libraries ---
#include <Servo.h>            // Will use the ESP32-compatible version
#include <math.h>
#include <Wire.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <MS5611.h>         // Using the Rob Tillaart MS5611 Library

// --- Objects ---
Servo servos[3];
Adafruit_MPU6050 mpu;
MS5611 ms5611(0x77); // Create barometer object (0x77 is default I2C address)
                     // Use 0x76 if the I2C scanner finds it there!

// --- Pin configuration ----
const int SERVO_PIN[3] = {13, 12, 14}; // NEW PINS FOR ESP32

// --- IK Geometry (CRITICAL: Match your real build!) ---
const float Rb = 80.0;
const float Rp = 60.0;
const float la = 40.0;
const float lr = 100.0;
const float baseZ = 0.0;

// Offsets and direction (for calibration)
const float servoOffset[3] = {0.0, 0.0, 0.0};
const int servoDir[3] = {1, 1, 1};
const float SERVO_MIN = 0.0;
const float SERVO_MAX = 180.0;

// 3D vector struct
struct Vec3 { float x, y, z; };
Vec3 baseAnchor[3];
Vec3 platformLocal[3];

// --- Control Logic Variables ---
const float Z_RAISED = 95.0;
const float Z_LOWERED = 65.0;
const float Z_FLAT = 80.0;

const float MAX_PLATFORM_TILT = 15.0; 
const float MPU_MAP_RANGE = 30.0; // 2:1 ratio (configurable)

// --- Barometer (Heave) Control Variables ---
float baseAltitude = 0.0; // Stores the calibrated "0" height (in meters)
float filteredZ_Meters = 0.0; // The smoothed altitude reading
// Map a +/- 15cm hand motion to the full platform height range
const float HEAVE_MAP_RANGE_METERS = 0.15; 
// Smoothing factor (0.0 = no smoothing, 1.0 = no change)
// A higher value = more smoothing but more "lag"
const float Z_FILTER_ALPHA = 0.75; 


// --- Utility (from previous code) ---
float toRad(float d){ return d * M_PI / 180.0; }
float toDeg(float r){ return r * 180.0 / M_PI; }


// ==========================================================
//                     SETUP FUNCTION
// ==========================================================
void setup() {
  Serial.begin(115200);
  Serial.println("ESP32 Stewart Platform MPU + Barometer Controller Initializing...");
  Serial.println("Using Rob Tillaart MS5611 Library.");

  // 1. Initialize I2C Bus on ESP32
  Wire.begin(21, 22); // NEW LINE: Explicitly set SDA=21, SCL=22

  // 2. Initialize MPU-6050
  if (!mpu.begin()) {
    Serial.println("Failed to find MPU6050 chip");
    while (1) { delay(10); } // Freeze
  }
  Serial.println("MPU6050 Found!");
  
  mpu.setAccelerometerRange(MPU6050_RANGE_8_G);
  mpu.setGyroRange(MPU6050_RANGE_500_DEG);
  mpu.setFilterBandwidth(MPU6050_BAND_21_HZ);

  // 3. Initialize MS5611 (Barometer)
  ms5611.begin(); // Initialize the sensor
  if (!ms5611.isConnected()) {
    Serial.println("Failed to find MS5611 chip");
    while (1) { delay(10); } // Freeze
  }
  Serial.println("MS5611 Barometer Found!");

  // 4. CALIBRATE BAROMETER
  Serial.println("Calibrating Barometer... Do not move sensor.");
  float alt_sum = 0;
  for (int i=0; i<100; i++) {
    ms5611.read(); // Read new pressure/temp data
    alt_sum += ms5611.getAltitude(); // Calculate altitude
    delay(5);
  }
  baseAltitude = alt_sum / 100.0;
  Serial.print("Base altitude set to: "); Serial.println(baseAltitude);


  // 5. Initialize Servos
  // The default Servo.h library on ESP32 is smart and
  // will allocate timers and channels automatically.
  setupAnchors();
  for (int i=0;i<3;i++) {
    servos[i].attach(SERVO_PIN[i]);
  }

  Serial.println("System Ready. Moving to start position.");
  setPose(0, 0, Z_FLAT, 0, 0, 0); // Start at neutral roll/pitch and flat height
  delay(1000);
}

// ==========================================================
//                      MAIN LOOP
// ==========================================================
void loop() {
  
  // 1. Read ALL inputs
  sensors_event_t a, g, temp;
  mpu.getEvent(&a, &g, &temp);

  // --- Read Roll/Pitch Input (MPU) ---
  float roll_rad = atan2(a.acceleration.y, a.acceleration.z);
  float pitch_rad = atan2(-a.acceleration.x, sqrt(a.acceleration.y * a.acceleration.y + a.acceleration.z * a.acceleration.z));
  float mpu_roll = roll_rad * 180.0 / M_PI;
  float mpu_pitch = pitch_rad * 180.0 / M_PI;

  // --- Calculate Heave/Height from Barometer (Altitude) ---
  ms5611.read(); // Read new pressure/temp data
  float currentAltitude = ms5611.getAltitude(); // Read height in meters
  // Find the height relative to our starting point
  float relativeHeight = currentAltitude - baseAltitude; 

  // Apply a low-pass filter to smooth out jitter
  // (NewValue * 0.25) + (OldValue * 0.75)
  filteredZ_Meters = ((1.0 - Z_FILTER_ALPHA) * relativeHeight) + (Z_FILTER_ALPHA * filteredZ_Meters);
  
  // Map the relative (and filtered) height to the platform's Z-Height
  float targetZ = map(filteredZ_Meters, 
                        -HEAVE_MAP_RANGE_METERS, HEAVE_MAP_RANGE_METERS, 
                        Z_LOWERED, Z_RAISED);
  targetZ = constrain(targetZ, Z_LOWERED, Z_RAISED);
  
  
  // 2. Define a "deadzone" for when the controller is stationary (Roll/Pitch)
  const float DEADZONE_DEGREES = 3.0;
  float targetRoll = 0;
  float targetPitch = 0;
  
  if (abs(mpu_roll) < DEADZONE_DEGREES && abs(mpu_pitch) < DEADZONE_DEGREES) {
    // ---- CONTROLLER IS STATIONARY (in tilt) ----
    targetRoll = 0;
    targetPitch = 0;
    // targetZ is already set from the Barometer calculation
    
  } else {
    // ---- CONTROLLER IS MOVING ----
    
    // 3. Map and Constrain the angles for the platform
    targetRoll = map(mpu_roll, 
                           -MPU_MAP_RANGE, MPU_MAP_RANGE, 
                           -MAX_PLATFORM_TILT, MAX_PLATFORM_TILT);
                           
    targetPitch = map(mpu_pitch, 
                            -MPU_MAP_RANGE, MPU_MAP_RANGE, 
                            -MAX_PLATFORM_TILT, MAX_PLATFORM_TILT);

    // Constrain to prevent impossible angles
    targetRoll = constrain(targetRoll, -MAX_PLATFORM_TILT, MAX_PLATFORM_TILT);
    targetPitch = constrain(targetPitch, -MAX_PLATFORM_TILT, MAX_PLATFORM_TILT);
    
    // targetZ is already set from the Barometer calculation
  }

  // 4. Send the final pose to the IK solver
  // We use 0 for tx, ty, and yaw, as we only control z, roll, and pitch
  setPose(0, 0, targetZ, targetRoll, targetPitch, 0);

  // Optional: Print to Serial Monitor for debugging
  // Serial.print("Roll: "); Serial.print(targetRoll);
  // Serial.print("\t Pitch: "); Serial.print(targetPitch);
  // Serial.print("\t Height (m): "); Serial.print(filteredZ_Meters);
  // Serial.print("\t TargetZ: "); Serial.println(targetZ);

  // Delay to keep a steady update rate
  delay(10); // 10ms delay for a ~100Hz loop
}


// ==========================================================
//            INVERSE KINEMATICS FUNCTIONS
// ==========================================================

// Pre-compute anchor coordinates
void setupAnchors() {
  for (int i = 0; i < 3; i++) {
    float ang = toRad(i * 120.0);      // base @ 0°,120°,240°
    baseAnchor[i] = { Rb*cos(ang), Rb*sin(ang), baseZ };
    platformLocal[i] = { Rp*cos(ang), Rp*sin(ang), 0.0 };
  }
}

// Apply roll-pitch-yaw rotation
void rotateRPY(const Vec3 &in, Vec3 &out, float roll, float pitch, float yaw) {
  float cr = cos(roll), sr = sin(roll);
  float cp = cos(pitch), sp = sin(pitch);
  float cy = cos(yaw), sy = sin(yaw); // Corrected typo here
  out.x = cy*cp*in.x + (cy*sp*sr - sy*cr)*in.y + (cy*sp*cr + sy*sr)*in.z;
  out.y = sy*cp*in.x + (sy*sp*sr + cy*cr)*in.y + (sy*sp*cr - cy*sr)*in.z;
  out.z = -sp*in.x   + cp*sr*in.y                 + cp*cr*in.z;
}

// Compute one servo angle
bool computeAngle(int i, float tx, float ty, float tz,
                  float roll, float pitch, float yaw, float &angleOut) {
  Vec3 pl = platformLocal[i], pr;
  rotateRPY(pl, pr, toRad(roll), toRad(pitch), toRad(yaw));
  Vec3 pw = { pr.x + tx, pr.y + ty, pr.z + tz };

  float dx = pw.x - baseAnchor[i].x;
  float dy = pw.y - baseAnchor[i].y;
  float dz = pw.z - baseAnchor[i].z;

  float h = sqrt(dx*dx + dy*dy);
  float d = sqrt(dx*dx + dy*dy + dz*dz);
  if (d < 1e-6) return false;

  float cosb = (la*la + d*d - lr*lr) / (2.0 * la * d);
  cosb = constrain(cosb, -1.0, 1.0);
  float beta = acos(cosb);
  float phi  = atan2(dz, h);
  float theta = phi + beta;
  float deg = toDeg(theta);
  deg = servoDir[i]*deg + servoOffset[i];
  deg = constrain(deg, SERVO_MIN, SERVO_MAX);
  angleOut = deg;
  return true;
}

// Command all three servos for a pose
bool setPose(float tx, float ty, float tz, float roll, float pitch, float yaw) {
  float a[3];
  for (int i=0;i<3;i++){
    if(!computeAngle(i,tx,ty,tz,roll,pitch,yaw,a[i])) return false;
    servos[i].write((int)round(a[i]));
  }

  // Print the final output to Serial Monitor for debugging
  Serial.print("Pose Z="); Serial.print(tz);
  Serial.print(" R="); Serial.print(roll);
  Serial.print(" P="); Serial.print(pitch);
  Serial.print(" -> Angles: ");
  for(int i=0;i<3;i++){ Serial.print((int)a[i]); if(i<2) Serial.print(","); }
  Serial.println();
  
  return true;
}
